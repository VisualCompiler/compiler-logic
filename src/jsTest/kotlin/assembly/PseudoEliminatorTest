import {
  pseudo,
  stack,
  register,
  mov,
  asmUnary,
  asmBinary,
  ret,
  asmProgram,
  asmFunction,
  AsmUnaryOp,
  AsmBinaryOp,
} from './__mocks__/assembly';

// This is our JavaScript simulation of the Kotlin PseudoEliminator class.
// The logic is identical to the Kotlin implementation.
class PseudoEliminator {
  eliminate(program) {
    const pseudoToOffset = new Map();
    let nextAvailableOffset = 0;

    const getStackLocation = (name) => {
      if (pseudoToOffset.has(name)) {
        return stack(pseudoToOffset.get(name));
      }
      nextAvailableOffset -= 4;
      pseudoToOffset.set(name, nextAvailableOffset);
      return stack(nextAvailableOffset);
    };

    const replace = (operand) => (operand.type === 'Pseudo' ? getStackLocation(operand.name) : operand);

    const newInstructions = program.function.body.map((instruction) => {
      switch (instruction.type) {
        case 'Mov':
          return mov(replace(instruction.src), replace(instruction.dest));
        case 'AsmUnary':
          return asmUnary(instruction.op, replace(instruction.dest));
        case 'AsmBinary':
          return asmBinary(instruction.op, replace(instruction.src), replace(instruction.dest));
        default:
          return instruction;
      }
    });

    const newFunction = { ...program.function, body: newInstructions };
    return { program: { function: newFunction }, stackSpaceUsed: -nextAvailableOffset };
  }
}


describe('PseudoEliminator', () => {
  let eliminator;

  beforeEach(() => {
    eliminator = new PseudoEliminator();
  });

  test('should replace a single pseudo-register with a stack offset', () => {
    // Arrange
    const program = asmProgram(
      asmFunction('main', [
        mov(pseudo('tmp.0'), register('EAX'))
      ])
    );

    // Act
    const result = eliminator.eliminate(program);

    // Assert
    const expectedProgram = asmProgram(
      asmFunction('main', [
        mov(stack(-4), register('EAX'))
      ])
    );

    expect(result.stackSpaceUsed).toBe(4);
    expect(result.program).toEqual(expectedProgram);
  });

  test('should assign unique offsets to multiple different pseudo-registers', () => {
    // Arrange
    const program = asmProgram(
      asmFunction('main', [
        mov(pseudo('tmp.0'), register('EAX')),
        asmBinary(AsmBinaryOp.ADD, pseudo('tmp.1'), register('EAX')),
      ])
    );

    // Act
    const result = eliminator.eliminate(program);

    // Assert
    const expectedProgram = asmProgram(
      asmFunction('main', [
        mov(stack(-4), register('EAX')),
        asmBinary(AsmBinaryOp.ADD, stack(-8), register('EAX')),
      ])
    );

    expect(result.stackSpaceUsed).toBe(8);
    expect(result.program).toEqual(expectedProgram);
  });

  test('should reuse the same stack offset for multiple uses of the same pseudo-register', () => {
    // Arrange
    const program = asmProgram(
      asmFunction('main', [
        mov(pseudo('tmp.0'), register('EAX')),
        mov(register('EAX'), pseudo('tmp.1')),
        asmBinary(AsmBinaryOp.SUB, pseudo('tmp.0'), pseudo('tmp.1')),
      ])
    );

    // Act
    const result = eliminator.eliminate(program);

    // Assert
    const expectedProgram = asmProgram(
      asmFunction('main', [
        mov(stack(-4), register('EAX')),
        mov(register('EAX'), stack(-8)),
        asmBinary(AsmBinaryOp.SUB, stack(-4), stack(-8)),
      ])
    );

    expect(result.stackSpaceUsed).toBe(8);
    expect(result.program).toEqual(expectedProgram);
  });

  test('should do nothing if there are no pseudo-registers', () => {
    // Arrange
    const program = asmProgram(
      asmFunction('main', [
        mov(register('EBX'), register('EAX')),
        ret()
      ])
    );
    const originalProgram = JSON.parse(JSON.stringify(program)); // Deep copy

    // Act
    const result = eliminator.eliminate(program);

    // Assert
    expect(result.stackSpaceUsed).toBe(0);
    expect(result.program).toEqual(originalProgram);
  });
});